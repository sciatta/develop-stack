# 线性表

## 链表

### 静态链表

基于数组实现，元素包括value和cursor，其中cursor指向数组中的任意一个元素的索引位置。实现的思路是创建两条虚拟链表，一条是备用链表，作用是连接未使用的空间；另一条是数据链表，作用是连接数据链表的各个节点。

- 数组的第一个元素保留，作为备用链表的头节点；数组的最后一个元素保留，作为数据链表的头结点
- 数据链表是否为空，判断数据链表的头结点，即数组的最后一个元素的curse是否等于0，为0则数据链表为空
- 数据链表是否为满，假设底层实现的数组不支持动态扩充，判断备用链表的头结点是否指向数组的最后一个元素，即curse等于n-1，则数据链表为满



![linear_linkedlist_static](数据结构和算法.assets/linear_linkedlist_static.png)



### 单链表反转

- `cur` 指向待反转节点，`pre` 指向待反转节点的前驱节点

- 反转过程

  ```java
  head.next = cur;
  cur = cur.next;
  head.next.next = pre;
  pre = head.next;
  ```

  

![linear_linkedlist_reverse](数据结构和算法.assets/linear_linkedlist_reverse.png)

### 链表中环的检测

- 判断链表是否存在环

  通过快指针和慢指针算法检测。首先快指针和慢指针都指向第一个节点，快指针走两步，慢指针走一步。如果有环，快指针会先进入环，慢指针后进入环，快指针逐渐靠近慢指针并在环上的某一点相遇，而不会跳过慢指针。

  - 证明（数学归纳法）

    慢指针和快指针相差步数为n，则：

    1. 当n=1时，慢指针向前走一步，快指针向前走两步，刚好相遇，即 `x=1(相差步数)+1（慢指针走一步）-2（快指针走两步）=0`
    2. 当n=2时，慢指针向前走一步，快指针向前走两步，之后快指针比慢指针落后一步，即 `x=2+1-2=1`，转换为1
    3. 假设当n=k时(k>=1)成立
    4. 则当n=k+1时，`x=k+1+1-2=k` ，转换为3；因此，可以证明当n>=1时，结论成立。



- 如果存在环，求环的长度

  慢指针从相遇节点开始向前走，直到再次到达相遇节点绕环一周，即为环的长度。



- 如果存在环，求环的入口

  ![linear_linkedlist_entry_of_ring](数据结构和算法.assets/linear_linkedlist_entry_of_ring.png)
  a长度是从第一个节点到环入口节点的长度；b长度是从环入口节点到快慢指针相遇节点的长度；c长度是从相遇节点到环入口节点的长度，因为快指针先进入环，而慢指针后进入环，快指针追上慢指针至少绕环一周；a的长度等于c的长度。

  - 证明

    当快指针和慢指针在环内相遇

    - 慢指针走的长度s=a+b

    - 快指针走的长度f=a+(b+c)*n+b，其中b+c是环的长度，n是快指针已经绕环圈数

    - 因为快指针走的长度是慢指针的2倍，所以 2s=f，即 

      `2(a+b)=a+(b+c)*n+b`  =>

      `a=(b+c)*n-b`  =>

      `a=(b+c)*(n-1)+(b+c)*1-b`  =>

      `a=(b+c)*(n-1)+c`

    - 则当n>=1时，a=c